<?php namespace ExternalModules;

use \Exception;

require_once __DIR__ . '/../tests/phpcs-shared/SniffMessages.php';

class Scan
{
	/**
	 * This version should lag a little behind REDCap's System::minimum_php_version_required
	 * since it takes a while for most institutions to update, and some modules (e.g. Flight Tracker)
	 * want to keep supporting old REDCap versions in the meantime.
	 */
	const TARGET_PHP_VERSION = '7.2.5';
	const CONFIG_FILENAME = 'config.json';

	private $exitAction;
	private $config;
	private $composerConfig;
	private $composerInstallingMessageShown = false;

	static function run($exitAction, $outputFile, $path){
		$s = new Scan();
		$s->exitAction = $exitAction;

		if(version_compare(PHP_VERSION, '7.4', '<')){
			echo "\n";
			$s->showWarning('It is recommended to run this tool on PHP 7.4 or newer to find the most potential vulnerabilities, and avoid the most false positives.');
		}

		chdir(APP_PATH_EXTMOD);
		$s->installComposer();

		echo "\n";

		chdir($path);

		$s->replaceStringsThatInterfereWithTheScan($path);

		$returnCode = 0;
		$output = '';
		foreach([
			'checkComposerConfig',
			'checkForSystemHooks',
			'scanJavaScriptFiles',
			'runPHPCS',
			'runPsalm',
		] as $methodName){
			ob_start();
			$errorsReturned = !empty($s->$methodName());
			$currentCommandOutput = trim(ob_get_contents());
			ob_end_clean();
			
			// file_put_contents(__DIR__ . "/$methodName", $currentCommandOutput);

			if($errorsReturned){
				$returnCode = 1;
				$output .= "$currentCommandOutput\n\n\n";
			}
		}

		if($returnCode === 0){
			$output = "The scan completed successfully, and no issues were detected!  This scan cannot guarantee security in all scenarios,\nand should not be considered a substitute for ensuring best practices are followed.";
		}
		else{
			$output .= "---------------------------------------------------------------------------------------------\n\n";
			$output .= "Please review the results above, consider any WARNINGs, and address any ERRORs.\nSolutions to ERRORs should also be applied in comparable scenarios throughout the codebase,\nas this scan is not capable of finding all potential vulnerabilities.\nIf you encounter false positives, or have any other difficulties running scans,\nplease reach out to Mark McEver via mark.mcever@vumc.org or community.projectredcap.org.";
		}

		if($outputFile){
			$output = htmlspecialchars($output, ENT_QUOTES);
			$output = ExternalModules::ansiToHtml($output);
			$output = "
				<div>
					This file was generated by the <b>scan</b> script bundled with REDCap.<br>
					To learn more, go to
					<b>" . implode(' -> ', [
						'Control Center',
						'External Modules',
						'Manage',
						'Module Security Scanning',
					]) . "</b>.
				</div>
				<br>
				$output
			";

			file_put_contents($outputFile, $output);
		}
		else{
			echo "$output\n\n";
		}

		return $returnCode;
	}

	private function replaceStringsThatInterfereWithTheScan($rootPath){
		foreach(new \DirectoryIterator($rootPath) as $item){
			$path = $item->getPathname();
			if($item->isDot()){
				continue;
			}
			else if($item->isDir()){
				if(realpath($path) === realpath($this->getVendorPath())){
						// Skip the vendor dir, since we have psalm configured to ignore it anyway.
						continue;
				}
				$this->replaceStringsThatInterfereWithTheScan($path);
			}
			else if(strtolower($item->getExtension()) === 'php'){
				$content = file_get_contents($path);
				
				$replacementsMade = false;
				foreach([
					'@codingStandardsIgnore', // Covers multiple attributes with this prefix
					'phpcs:ignore', // Covers multiple attributes with this prefix
					'phpcs:disable',
				] as $s){
					$replacement = 'disabled-' . str_replace('@', '', $s);
					$content = str_replace($s, $replacement, $content, $count);

					if($count > 0){
						$replacementsMade = true;
					}
				}

				if($replacementsMade){
					file_put_contents($path, $content);
				}
			}
		}
	}

	private function getComposerConfig(){
		if(!isset($this->composerConfig)){
			$this->composerConfig = [];

			$composerPath = "composer.json";
			if(file_exists($composerPath)){
				$composerConfig = json_decode(file_get_contents($composerPath), true);
				if(empty($composerConfig['require'])){
					/**
					 * Only 'require-dev' dependencies exist.  Remove composer.json to prevent psalm from getting confused & failing.
					 */
					unlink($composerPath);
				}
				else{
					$this->composerConfig = $composerConfig;
				}
			}
		}

		return $this->composerConfig;
	}

	private function getVendorPath(){
		return $this->getComposerConfig()['config']['vendor-dir'] ?? 'vendor/';
	}

	function setComposerConfig($config){
		$this->composerConfig = $config;
	}

	private function exit($message){
		$action = $this->exitAction;
		$action(1, $message);
	}

	private function getEMVendorPath(){
		return APP_PATH_EXTMOD . "vendor";
	}

	private function getEMAlternateDependenciesPath(){
		return $this->getEMVendorPath() . '/alternate-dependencies';
	}

	private function getEMAlternateVendorPath(){
		return $this->getEMAlternateDependenciesPath() . '/vendor';
	}

	private function installComposer(){
		if(!is_writable(APP_PATH_EXTMOD)){
			$this->exit("This script requires that the current user have write access the following path: " . APP_PATH_EXTMOD);
		}

		$vendorPath = $this->getEMVendorPath();
		$composerPath = "$vendorPath/composer.phar";
		$downloadComposer = true;
		if(file_exists($composerPath)){
			$oneYear = 60*60*24*365;
			$ageOfComposer = time() - filemtime($composerPath);
			if($ageOfComposer < $oneYear){
				$downloadComposer = false;
			}
		}

		if($downloadComposer){
			if(!file_exists($vendorPath)){
				mkdir($vendorPath);
			}

			$composerUrl = 'https://getcomposer.org/download/latest-stable/composer.phar';
			if(!copy($composerUrl, $composerPath)){
				$this->exit("Failed to download composer from '$composerUrl'.  If a firewall is preventing the download, please manually download that file to '$composerPath'.");
			};
		}

		$this->runComposerInstall($composerPath);

		$newerPsalmMinPHPVersion = '7.4.0';
		if(version_compare(PHP_VERSION, $newerPsalmMinPHPVersion, '>=')){
			/**
			 * We really want to take advantage of Mark's pull requests in recent psalm versions,
			 * but psalm 5+ requires PHP 7.4, which is unavailable on REDCap Test.
			 * This workaround allows newer versions of psalm to use only on systems that support them.
			 */

			$composerJson = file_get_contents(APP_PATH_EXTMOD . 'composer.json');
			if(!str_contains($composerJson, '"php": "7.3.0"')){
				throw new \Exception("It looks like our php platform version is now greater than 7.3.  That likely means the surrounding code block can be removed, as there is no longer a need to install a secondary set of dependencies for 7.4+.");
			}

			$alternateDir = $this->getEMAlternateDependenciesPath();
			if(!file_exists($alternateDir)){
				mkdir($alternateDir);
			}

			$psalmPackageName = 'vimeo/psalm';
			$alternatePsalmVersion = '5.9.0'; // Must be exact version for lock file check to work below
			file_put_contents("$alternateDir/composer.json", '
				{
					"config": {
						"platform": {
							"php": "' . $newerPsalmMinPHPVersion .'"
						}
					},
					"require-dev": {
						"'.$psalmPackageName.'": "'.$alternatePsalmVersion.'"
					}
				}
			');

			$originalDir = getcwd();
			chdir($alternateDir);
			
			$lockPath = 'composer.lock';
			if(file_exists($lockPath)){
				$lock = json_decode(file_get_contents($lockPath), true);
				foreach($lock['packages-dev'] as $package){
					if(
						$package['name'] === $psalmPackageName
						&&
						version_compare($alternatePsalmVersion, $package['version'], '!=')
					){
						// The version has changed.  Remove the lock file and let psalm regenerate it
						unlink($lockPath);
					}
				}
			}

			$this->runComposerInstall($composerPath);
			chdir($originalDir);
		}
		else{
			// Useful when switching back to old PHP versions for testing
			ExternalModules::rrmdir($this->getEMAlternateDependenciesPath());
		}
	}

	function runComposerInstall($composerPath){
		$process = proc_open(
			"php $composerPath install -q", [
				0 => ['pipe', 'r'],
				1 => ['pipe', 'w'],
				2 => ['pipe', 'w'],
			],
			$pipes
		);

		$startTime = time();
		while(true){
			usleep(100000);

			$secondsElapsed = time() - $startTime;
			if($secondsElapsed >= 5 && !$this->composerInstallingMessageShown){
				echo "Running composer install in " . APP_PATH_EXTMOD . "\n";
				$this->composerInstallingMessageShown = true;
			}

			$status = proc_get_status($process);
			if(!$status['running']){
				break;
			}
		}

		if($status['exitcode'] !== 0){
			$output = stream_get_contents($pipes[1]);
			$error = stream_get_contents($pipes[2]);
			$this->exit("Composer install in '" . getcwd() . "' failed with the following output:\n$output\n\n$error");
		}

		proc_close($process);
	}

	private function isModule(){
		return file_exists(static::CONFIG_FILENAME);
	}

	private function getConfig(){
		if(!isset($this->config)){
			if(!$this->isModule()){
				// This is a plugin or hook.
				$config = [];
			}
			else{
				$config = json_decode(file_get_contents(static::CONFIG_FILENAME), true);
				if(!isset($config['namespace'])){
					throw new Exception('Error parsing config.json');
				}
			}

			$this->setConfig($config);
		}

		return $this->config;
	}

	function setConfig($config){
		$this->config = $config;
	}

	function checkComposerConfig(){
		$composerConfig = $this->getComposerConfig();
		if($composerConfig === []){
			// Composer is not used, so nothing to check
			return;
		}

		$composerPHPVersion = $composerConfig['config']['platform']['php'] ?? '';
		$moduleMin = $this->getConfig()['compatibility']['php-version-min'] ?? '';
		$target = static::TARGET_PHP_VERSION;
		$errorShown = false;
		if($composerPHPVersion === ''){
			if(version_compare($target, $moduleMin, '>')){
				$recommendedVersion = $target;
				$recommendedVersionSource = null;
			}
			else{
				$recommendedVersion = $moduleMin;
				$recommendedVersionSource = 'your module';
			}

			$this->showError($this->getComposerVersionMissingMessage($recommendedVersion, $recommendedVersionSource));
			$errorShown = true;
		}
		else if(
			version_compare($composerPHPVersion, $target, '>')
			&&
			version_compare($composerPHPVersion, $moduleMin, '>')
		){
			$this->showError($this->getComposerHigherThanModulePHPVersionMessage());
			$errorShown = true;
		}

		return $errorShown;
	}

	function getComposerVersionMissingMessage($recommendedVersion, $recommendedVersionSource){
		$valueString = $recommendedVersion;
		if($recommendedVersionSource !== null){
			$valueString .= " ($recommendedVersionSource's minimum required version)";
		}

		return $this->formatMessage("
			A platform PHP version should be set in composer.json to ensure dependencies are compatible with the desired PHP versions.
			A value of $valueString is recommended, and can be added to composer.json via the following commands:

				composer config platform.php $recommendedVersion
				composer update
		");
	}

	function getComposerHigherThanModulePHPVersionMessage(){
		return $this->formatMessage("
			The platform PHP version in composer.json should be lesser than or equal to php-version-min in config.json.
			This ensures that the module cannot be enabled on any systems where the dependencies are not supported.
		");
	}

	private function checkForSystemHooks(){
		if(!$this->isModule()){
			return;
		}

		$warningDisplayed = false;
		$config = $this->getConfig();

		$showWarning = function($message) use (&$warningDisplayed){
			$warningDisplayed = true;
			$this->showWarning($message);
		};

		if($config['enable-every-page-hooks-on-system-pages'] ?? false === true){
			$showWarning("
				The 'enable-every-page-hooks-on-system-pages' flag is set to 'true' in config.json.
				If this is not intentional, please remove this flag from config.json.
				If this flag is required, please review any changes since the last scan
				that could influence the behavior of any hooks beginning with 'redcap_every_page_'.
				Please ensure that any such hooks return immediately if the expected page/context is not detected.
			");
		}

		if($config['enable-email-hook-in-system-contexts'] ?? false === true){
			$showWarning("
				The 'enable-email-hook-in-system-contexts' flag is set to 'true' in config.json.
				If this is not intentional, please remove this flag from config.json.
				If this flag is required, please review any changes since the last scan
				that could influence the behavior of the 'redcap_email' hook.
				Please ensure that it can appropriately handle any & all emails sent by REDCap
				or any other external modules.
			");
		}

		if($config['enable-no-auth-logging'] ?? false === true){
			$showWarning("
				The 'enable-no-auth-logging' flag is set to 'true' in config.json.
				If logging is not required for unauthenticated users, please remove this flag from config.json.
				If this flag is required, please review changes since the last scan that could influence unauthenticated log behavior.
				To minimize risk of exploitation, please use hard coded strings or allow lists for logged variables wherever possible.
				If any logged values must be sourced from request variables, please ensure that a malicious actor cannot use those values 
				to compromise security or adversely influence module behavior in any way.
				Please review both PHP and JavaScript log() calls.
			");
		}

		if($config['no-auth-ajax-actions'] ?? false === true){
			$showWarning("
				The 'no-auth-ajax-actions' flag is set to 'true' in config.json.
				If the JavaScript module.ajax() method is not required for unauthenticated users, please remove this flag from config.json.
				If this flag is required, please review changes since the last scan that could influence unauthenticated ajax() call behavior.
				To minimize risk of exploitation, please use hard coded strings or allow lists for the ajax data/payload wherever possible.
				If any portion of the data/payload must be sourced from request variables, please ensure that a malicious actor cannot use that data 
				to compromise security or adversely influence module behavior in any way.
			");
		}

		return $warningDisplayed;
	}

	/**
	 * Psalm already does a good job of detecting risky eval() calls in PHP.
	 * This method detects them in JS files.
	 * 
	 * We originally used PHPCS to scan JS files, but it ran out of memory trying to tokenize large JS files, like in the following module:
	 * https://github.com/dr01d3r/redcap-em-biospecimen-tracking/releases/download/v0.9.2-beta/biospecimen_tracking_v0.9.2.zip
	 * 
	 * We also considered using PHPCS's eslint support, but that would require
	 * a Node & Rhino dependency which is not worth the hassle for now.
	 */
	private function scanJavaScriptFiles(){
		$errorsExist = false;
		foreach (
			$iterator = new \RecursiveIteratorIterator(
				new \RecursiveDirectoryIterator(getcwd(), \RecursiveDirectoryIterator::SKIP_DOTS),
				\RecursiveIteratorIterator::SELF_FIRST
			) as $unused
		) {
			$path = $iterator->getSubPathname();
			if(str_ends_with($path, '.js') && is_file($path)){
				$handle = fopen($path, "r");
				if(!$handle){
					throw new \Exception('Error opening file: ' . $path);
				}

				$lineNumber = 1;
				while (($line = fgets($handle)) !== false) {
					if(SniffMessages::doesLineContainJSEval($line)){
						echo "$path:$lineNumber - " . SniffMessages::JS_EVAL . "\n";
						$errorsExist = true;
					}

					$lineNumber++;
				}

				fclose($handle);				
			}
		}

		return $errorsExist;
	}

	private function showWarning($message, $return = false){
		$this->showMessage('WARNING', $message);
	}

	private function showError($message){
		$this->showMessage('ERROR', $message);
	}

	private function showMessage($type, $message){
		echo "[0;31m$type[0m: " . $this->formatMessage($message);
	}

	static function formatMessage($message){
		$lines = explode("\n", $message);

		$newMessage = '';
		$codeIndentation = null;
		foreach($lines as $line){
			if($codeIndentation === null && !empty(trim($line))){
				preg_match('/\s*/', $line, $matches);
				$codeIndentation = $matches[0];
			}

			$newMessage .= str_replace($codeIndentation ?? '', '', $line) . "\n";
		}

		// Trim leading & trailing newlines AFTER handling $codeIndentation
		$newMessage = trim($newMessage);

		$newMessage .= "\n\n";

		return $newMessage;
	}

	private function getCommandSeparatorLines($label){	
		return implode("\n", [
			"------------------------------------------------------------",
			"Running $label",
			"",
		]);
	}

	private function runPsalm(){
		putenv('PSALM_ALLOW_XDEBUG=1');

		$psalmArgs = ' --php-version='. ExternalModules::limitVersion(static::TARGET_PHP_VERSION, 2);

		$tempPath = getcwd();
		$cachePath = "$tempPath/psalm-cache";
		mkdir($cachePath);

		static::createPsalmConfig($tempPath, basename($cachePath));

		$vendorPath = $this->getEMAlternateVendorPath();
		if(!file_exists($vendorPath)){
			$vendorPath = $this->getEMVendorPath();
		}

		$psalmPath = "$vendorPath/bin/psalm";
		if(PHP_OS_FAMILY === "Windows"){
			$psalmPath .= '.bat';
		}

		// $psalmPath = 'php ~/downloads/psalm/psalm'; // Keep for occasional testing of psalm dev versions

		$runCommand = function($command, $label){
			$output = $this->getCommandSeparatorLines($label);
			$lines = [];

			exec($command, $lines, $result);

			$appendRecommendedSolution = function($line){
				$errorLinePrefix = "[0;31mERROR[0m:";
				$getSolution = function($line) use ($errorLinePrefix){
					$htmlSolution = implode("\n", [
						'htmlspecialchars($taintedString, ENT_QUOTES)[0m. In REDCap version 13.1.2, a [30;47m$module->escape()[0m method',
						'was added that avoids boilerplate in more complex cases by recursively escaping arrays and preserving primitive types.',
						'It will become the recommendation once most institutions update to that REDCap version.',
						'On older REDCap versions, the [30;47mescape()[0m method can be used now by copying it into your module class ',
						'from [30;47m<newer-redcap-version-source>/ExternalModules/classes/ExternalModules.php',
					]);

					$solutionsByType = [
						'TaintedHtml' => $htmlSolution,
						'TaintedShell' => 'escapeshellcmd($taintedString)[0m or [30;47mescapeshellarg($taintedString)',
						'TaintedTextWithQuotes' => $htmlSolution,
					];

					$isTaint = function($type) use ($line, $errorLinePrefix){
						return str_starts_with($line, "$errorLinePrefix $type");
					};

					if($isTaint('TaintedSql')){
						return [
							'To resolve this, use the [30;47m$module->query()[0m method and pass the variable highlighted at the last step of the trace',
							'as a parameter via the second argument to the [30;47mquery()[0m method.  See REDCap\'s developer documentation for details.'
						];
					}
					else if($isTaint('TaintedFile') || $isTaint('TaintedInclude')){
						return [
							'To resolve this, use the [30;47m$module->getSafePath()[0m method to obtain a path that is guaranteed',
							'to be within the expected parent directory. See REDCap\'s developer documentation for details.'
						];
					}

					foreach($solutionsByType as $type=>$solution){
						if($isTaint($type)){
							return [
								"This is generally resolved by finding the simplest highlighted variable in the trace below (ideally a short string)",
								"and wrapping it in [30;47m$solution[0m.",
							];
						}
					}

					return null;
				};

				$lines = [$line];
				
				if(str_starts_with($line, $errorLinePrefix)){
					$solution = $getSolution($line);
					if($solution !== null){
						array_push($lines, ...$solution);
					}

					array_push($lines, "");
				}

				array_push($lines, "");

				return $lines;
			};

			foreach($lines as $line){
				$output .= implode("\n", $appendRecommendedSolution($line));
			}

			echo trim($output);

			return $result;
		};

		$returnCode = 0;

		/**
		 * Running psalm normally works, but it finds a bunch of things that we don't
		 * currently expect module authors to solve (including issues in REDCap core).
		 * We will likely leave this commented indefinitely.
		 */
		// $runCommand("$psalmPath $psalmArgs", "Psalm");

		$returnCode = $runCommand("$psalmPath $psalmArgs --taint-analysis --no-progress", "Psalm's Taint Analysis");

		return $returnCode;
	}

	private function createPsalmConfig($dirPath, $cacheDir){
		$attributes = 'errorLevel="8" ';

		$addAttribute = function($name, $value) use (&$attributes){
			$attributes .= "$name=\"$value\" ";
		};

		if($cacheDir !== null){
			$addAttribute('cacheDirectory', $cacheDir);
		}

		$emPath = $this->getRelativePath($dirPath, APP_PATH_EXTMOD);
		$addAttribute('autoloader', $emPath . '/psalm/autoload.php');

		$moduleClassRow = '';
		if($this->isModule()){
			$config = $this->getConfig();
			$parts = explode('\\', $config['namespace']);
			$parts[] = end($parts);
			$moduleClass = implode('\\', $parts);
			$moduleClassRow = '<var name="module" type="' . $moduleClass . '" />';
		}

		$sharedConfigSections = static::getSharedPsalmConfigSections();

		$plugins = '';
		if(version_compare(PHP_VERSION, '7.4', '>=')){
			$plugins .= '<plugin filename="' . __DIR__ . '/../psalm/REDCapPsalmPlugin.php' . '" />';
		}

		$psalmConfigXml = '<?xml version="1.0"?>
<psalm ' . $attributes . '>
	<projectFiles>
		<directory name="." />
		<ignoreFiles allowMissingFiles="true">
			<!-- Ignore the third party dependencies, because they can cause the scan to take a long time or hang on some modules -->
			<directory name="' . $this->getVendorPath() . '" />
			<directory name="node_modules" />
		</ignoreFiles>
	</projectFiles>
	<plugins>
		' . $plugins . '
	</plugins>
	<stubs>
		' . implode("\n\t\t", $sharedConfigSections['stubs']) . '
	</stubs>
	<globals>
		' . implode("\n\t\t", $sharedConfigSections['globals']) . '
		' . $moduleClassRow . '
	</globals>
</psalm>
';

		file_put_contents("$dirPath/psalm.xml", $psalmConfigXml);
	}

	private function getSharedPsalmConfigSections(){
		$config = simplexml_load_file(__DIR__ . '/../psalm.xml');

		$stubs = [];
		$globals = [];

		foreach($config->stubs->file as $file){
			$path = APP_PATH_EXTMOD . $file->attributes()['name']->__toString();
			$stubs[] = '<file name="' . $path . '" />';
		}

		$addGlobals = false;
		foreach($config->globals->var as $var){
			$name = $var->attributes()['name']->__toString();
			$type = $var->attributes()['type']->__toString();

			if($name === 'rc_connection'){
				// We're in the section of shared vars
				$addGlobals = true;
			}

			if($addGlobals){
				$globals[] = '<var name="' . $name . '" type="' . $type . '" />';
			}
		}

		return [
			'stubs' => $stubs,
			'globals' => $globals,
		];
	}

	/**
	 * Used for psalm, which doesn't accept absolute paths.
	 */
	private function getRelativePath($fromPath, $toPath){
		// Normalize any extraneous slashes
		$fromPath = realpath($fromPath);
		$toPath = realpath($toPath);

		$parts = explode(DIRECTORY_SEPARATOR, $fromPath);

		$result = "";
		array_pop($parts); // Don't account for leading slash
		foreach($parts as $part){
			$result .= "../";
		}

		$suffix = $toPath;
		if(PHP_OS_FAMILY === "Windows"){
			$suffix = explode(":", $suffix)[1];
		}

		return $result . $suffix;
	}

	private function runPHPCS(){
		echo $this->getCommandSeparatorLines('coding standard checks via phpcs');

		file_put_contents('ruleset.xml', '<?xml version="1.0"?>
			<ruleset>
				<rule ref="Internal.NoCodeFound">
					<severity>0</severity>
				</rule>
			</ruleset>
		');

		$minPhpVersion = $this->getConfig()['compatibility']['php-version-min'] ?? '';
		$redcapMinPhpVersion = static::TARGET_PHP_VERSION;
		if(version_compare($redcapMinPhpVersion, $minPhpVersion, '>')){
			$minPhpVersion = $redcapMinPhpVersion;
		}
		$minPhpVersion = ExternalModules::limitVersion($minPhpVersion, 2);

		$maxPhpVersion = $this->getConfig()['compatibility']['php-version-max'] ?? '';
		$maxPhpVersion = ExternalModules::limitVersion($maxPhpVersion, 2);
		if(version_compare($minPhpVersion, $maxPhpVersion, '>')){
			$maxPhpVersion = '';
		}

		$excludes = [
			'PHPCompatibility.FunctionUse.ArgumentFunctionsReportCurrentValue',
			'PHPCompatibility.Variables.NewUniformVariableSyntax',
			'PHPCompatibility.Extensions.RemovedExtensions',
			'PHPCompatibility.FunctionUse.NewFunctions', // Replaced by ExternalModules\Sniffs\Misc\NewFunctionsSniff
		];

		if(!$this->isModule()){
			/**
			 * We currently only require namespaces for modules (not plugins or hooks).
			 */
			$excludes[] = 'ExternalModules.Misc.RequireNamespace';
		}

		$emRoot = __DIR__ . '/..';
		$vendorPath = $this->getVendorPath();
		system(implode(' ', [
			"$emRoot/vendor/bin/phpcs --report-width=100 -d memory_limit=2G -s --runtime-set testVersion $minPhpVersion-$maxPhpVersion --extensions=php,vue --ignore=/{$vendorPath} .",
			"--standard=ruleset.xml,$emRoot/tests/phpcs-scan,$emRoot/tests/phpcs-shared,$emRoot/vendor/phpcompatibility/php-compatibility/PHPCompatibility",

			/**
			 * These are most relevant when moving from PHP 5-7.
			 * That was a while ago, so these are just noise at this point.
			 */
			"--exclude=" . implode(',', $excludes),
		]), $resultCode);

		return $resultCode;
	}
}